// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'bim/entities.dart';
import 'bim/geometry.dart';
import 'bim/model.dart';
import 'bim/model_registry.dart';
import 'frb_generated.dart';
import 'lib.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `dms_to_decimal`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `MeasurementType`, `SectionPlane`, `ViewMode`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`

/// Initialize the BIM viewer engine
/// This should be called once when the app starts
String initialize() => RustLib.instance.api.crateApiInitialize();

/// Get the library version
String getVersion() => RustLib.instance.api.crateApiGetVersion();

/// Get system information for debugging
String getSystemInfo() => RustLib.instance.api.crateApiGetSystemInfo();

/// Test async functionality
/// This demonstrates that async Rust functions work correctly across FFI
Future<String> testAsync() => RustLib.instance.api.crateApiTestAsync();

/// Test error handling across FFI
/// Returns a Result to demonstrate error propagation
String testErrorHandling({required bool shouldFail}) =>
    RustLib.instance.api.crateApiTestErrorHandling(shouldFail: shouldFail);

/// Load an IFC file and parse it (backward compatible - loads as primary)
/// This is async because file I/O can be slow
Future<ModelInfo> loadIfcFile({required String filePath}) =>
    RustLib.instance.api.crateApiLoadIfcFile(filePath: filePath);

/// Get information about the currently loaded model (primary model)
ModelInfo getModelInfo() => RustLib.instance.api.crateApiGetModelInfo();

/// Check if a model is currently loaded
bool isModelLoaded() => RustLib.instance.api.crateApiIsModelLoaded();

/// Unload the current model and free memory (primary model)
void unloadModel() => RustLib.instance.api.crateApiUnloadModel();

/// Parse IFC file content (for testing - takes content string instead of file path)
Future<ModelInfo> parseIfcContent({required String content}) =>
    RustLib.instance.api.crateApiParseIfcContent(content: content);

/// Load a model with a specific ID
Future<ModelInfo> loadModel({required String modelId, required String filePath}) =>
    RustLib.instance.api.crateApiLoadModel(modelId: modelId, filePath: filePath);

/// Unload a specific model by ID
void unloadModelById({required String modelId}) => RustLib.instance.api.crateApiUnloadModelById(modelId: modelId);

/// List all loaded models
List<RegisteredModelInfo> listLoadedModels() => RustLib.instance.api.crateApiListLoadedModels();

/// Get number of loaded models
BigInt getModelCount() => RustLib.instance.api.crateApiGetModelCount();

/// Set model visibility
void setModelVisible({required String modelId, required bool visible}) =>
    RustLib.instance.api.crateApiSetModelVisible(modelId: modelId, visible: visible);

/// Set the primary model
void setPrimaryModel({required String modelId}) => RustLib.instance.api.crateApiSetPrimaryModel(modelId: modelId);

/// Clear all models
void clearAllModels() => RustLib.instance.api.crateApiClearAllModels();

/// Test renderer initialization
/// This initializes the wgpu graphics backend (headless for now)
Future<String> testRendererInit() => RustLib.instance.api.crateApiTestRendererInit();

/// Initialize the 3D renderer with given dimensions
Future<String> initRenderer({required int width, required int height}) =>
    RustLib.instance.api.crateApiInitRenderer(width: width, height: height);

/// Render a frame and return RGBA pixel data
Uint8List renderFrame() => RustLib.instance.api.crateApiRenderFrame();

/// Orbit the camera around the target
void orbitCamera({required double deltaX, required double deltaY}) =>
    RustLib.instance.api.crateApiOrbitCamera(deltaX: deltaX, deltaY: deltaY);

/// Zoom the camera in/out
void zoomCamera({required double delta}) => RustLib.instance.api.crateApiZoomCamera(delta: delta);

/// Check if renderer is initialized
bool isRendererInitialized() => RustLib.instance.api.crateApiIsRendererInitialized();

/// Load the currently loaded BIM model into the renderer (primary model)
String loadModelIntoRenderer() => RustLib.instance.api.crateApiLoadModelIntoRenderer();

/// Load all visible models into the renderer
String loadAllModelsIntoRenderer() => RustLib.instance.api.crateApiLoadAllModelsIntoRenderer();

/// Fit camera to current model bounds (primary model)
void fitCameraToModel() => RustLib.instance.api.crateApiFitCameraToModel();

/// Fit camera to all visible models
void fitCameraToAllModels() => RustLib.instance.api.crateApiFitCameraToAllModels();

/// Pick element at screen coordinates (searches all visible models)
/// screen_x and screen_y are normalized (0-1) with origin at top-left
ElementInfo? pickElement({required double screenX, required double screenY}) =>
    RustLib.instance.api.crateApiPickElement(screenX: screenX, screenY: screenY);

/// Get all elements in the model (primary model)
List<ElementInfo> getAllElements() => RustLib.instance.api.crateApiGetAllElements();

/// Get all elements from all visible models
List<ElementInfo> getAllElementsFromAllModels() => RustLib.instance.api.crateApiGetAllElementsFromAllModels();

/// Get element count by type (primary model)
Map<String, BigInt> getElementCounts() => RustLib.instance.api.crateApiGetElementCounts();

/// Set visibility for an element type
void setElementTypeVisible({required String elementType, required bool visible}) =>
    RustLib.instance.api.crateApiSetElementTypeVisible(elementType: elementType, visible: visible);

/// Check if an element type is visible
bool isElementTypeVisible({required String elementType}) =>
    RustLib.instance.api.crateApiIsElementTypeVisible(elementType: elementType);

/// Get all hidden element types
List<String> getHiddenElementTypes() => RustLib.instance.api.crateApiGetHiddenElementTypes();

/// Get all grid lines from all visible models
List<GridLine> getGridLines() => RustLib.instance.api.crateApiGetGridLines();

/// Check if grid is visible
bool isGridVisible() => RustLib.instance.api.crateApiIsGridVisible();

/// Set grid visibility
void setGridVisible({required bool visible}) => RustLib.instance.api.crateApiSetGridVisible(visible: visible);

/// Toggle grid visibility
bool toggleGridVisible() => RustLib.instance.api.crateApiToggleGridVisible();

/// Get grid line count
BigInt getGridLineCount() => RustLib.instance.api.crateApiGetGridLineCount();

/// Get georeferencing data from the primary model's site
GeoReference? getGeoReference() => RustLib.instance.api.crateApiGetGeoReference();

/// Set the selected element for highlighting
void setSelectedElement({int? elementId}) => RustLib.instance.api.crateApiSetSelectedElement(elementId: elementId);

/// Reload model mesh with current visibility and highlight settings (primary model)
String reloadModelMesh() => RustLib.instance.api.crateApiReloadModelMesh();

/// Reload all visible models with current visibility and highlight settings
String reloadAllModelsMesh() => RustLib.instance.api.crateApiReloadAllModelsMesh();

/// Set the directional light direction (will be normalized)
/// Default is (0.5, 0.8, 0.3) - upper right front
void setLightDirection({required double x, required double y, required double z}) =>
    RustLib.instance.api.crateApiSetLightDirection(x: x, y: y, z: z);

/// Set the directional light color (RGB, 0.0-1.0)
/// Default is warm white (1.0, 0.98, 0.95)
void setLightColor({required double r, required double g, required double b}) =>
    RustLib.instance.api.crateApiSetLightColor(r: r, g: g, b: b);

/// Set the directional light intensity (0.0+)
/// Default is 1.0
void setLightIntensity({required double intensity}) =>
    RustLib.instance.api.crateApiSetLightIntensity(intensity: intensity);

/// Set the ambient light color (RGB, 0.0-1.0)
/// Default is soft blue (0.15, 0.17, 0.2)
void setAmbientColor({required double r, required double g, required double b}) =>
    RustLib.instance.api.crateApiSetAmbientColor(r: r, g: g, b: b);

/// Set the render mode
/// 0 = Shaded (default), 1 = Wireframe
void setRenderMode({required int mode}) => RustLib.instance.api.crateApiSetRenderMode(mode: mode);

/// Get the current render mode
/// Returns: 0 = Shaded, 1 = Wireframe
int getRenderMode() => RustLib.instance.api.crateApiGetRenderMode();

/// Check if wireframe rendering is supported on this device
bool isWireframeSupported() => RustLib.instance.api.crateApiIsWireframeSupported();

/// Start a new measurement
void startMeasurement({required String measurementType}) =>
    RustLib.instance.api.crateApiStartMeasurement(measurementType: measurementType);

/// Add a measurement point
/// Returns the current number of points
int addMeasurementPoint({required double x, required double y, required double z}) =>
    RustLib.instance.api.crateApiAddMeasurementPoint(x: x, y: y, z: z);

/// Get the current measurement result
MeasurementResult getMeasurementResult() => RustLib.instance.api.crateApiGetMeasurementResult();

/// Clear the current measurement
void clearMeasurement() => RustLib.instance.api.crateApiClearMeasurement();

/// Get the number of measurement points
int getMeasurementPointCount() => RustLib.instance.api.crateApiGetMeasurementPointCount();

/// Set the section plane
/// Origin: point on the plane
/// Normal: direction the plane faces (normalized)
void setSectionPlane(
        {required double originX,
        required double originY,
        required double originZ,
        required double normalX,
        required double normalY,
        required double normalZ}) =>
    RustLib.instance.api.crateApiSetSectionPlane(
        originX: originX, originY: originY, originZ: originZ, normalX: normalX, normalY: normalY, normalZ: normalZ);

/// Enable or disable the section plane
void setSectionPlaneEnabled({required bool enabled}) =>
    RustLib.instance.api.crateApiSetSectionPlaneEnabled(enabled: enabled);

/// Clear the section plane
void clearSectionPlane() => RustLib.instance.api.crateApiClearSectionPlane();

/// Check if section plane is active
bool isSectionPlaneActive() => RustLib.instance.api.crateApiIsSectionPlaneActive();

/// Set section plane from axis (X=0, Y=1, Z=2) and position
void setSectionPlaneFromAxis({required int axis, required double position}) =>
    RustLib.instance.api.crateApiSetSectionPlaneFromAxis(axis: axis, position: position);

/// Set element color by ID
void setElementColor({required int elementId, required int r, required int g, required int b}) =>
    RustLib.instance.api.crateApiSetElementColor(elementId: elementId, r: r, g: g, b: b);

/// Reset all element colors to defaults
void resetElementColors() => RustLib.instance.api.crateApiResetElementColors();

/// Color elements by type
/// Automatically assigns different colors to different element types
void colorByType() => RustLib.instance.api.crateApiColorByType();

/// Save current frame as PNG to the given path
Future<void> exportScreenshot({required String path}) => RustLib.instance.api.crateApiExportScreenshot(path: path);

/// Get current frame as RGBA bytes
/// Returns width, height, and pixel data
Uint8List getCurrentFrameRgba() => RustLib.instance.api.crateApiGetCurrentFrameRgba();

RenderStats getRenderStats() => RustLib.instance.api.crateApiGetRenderStats();

/// Upload a 2D drawing/floor plan as an overlay texture
/// id: Unique identifier for this overlay
/// width, height: Image dimensions
/// rgba_pixels: RGBA pixel data (width * height * 4 bytes)
Future<void> uploadDrawingOverlay(
        {required String id, required int width, required int height, required List<int> rgbaPixels}) =>
    RustLib.instance.api.crateApiUploadDrawingOverlay(id: id, width: width, height: height, rgbaPixels: rgbaPixels);

/// Set overlay transform (position, scale, rotation)
void setOverlayTransform(
        {required String id,
        required double positionX,
        required double positionY,
        required double positionZ,
        required double scaleX,
        required double scaleY,
        required double rotation}) =>
    RustLib.instance.api.crateApiSetOverlayTransform(
        id: id,
        positionX: positionX,
        positionY: positionY,
        positionZ: positionZ,
        scaleX: scaleX,
        scaleY: scaleY,
        rotation: rotation);

/// Set overlay opacity (0.0 to 1.0)
void setOverlayOpacity({required String id, required double opacity}) =>
    RustLib.instance.api.crateApiSetOverlayOpacity(id: id, opacity: opacity);

/// Set overlay visibility
void setOverlayVisible({required String id, required bool visible}) =>
    RustLib.instance.api.crateApiSetOverlayVisible(id: id, visible: visible);

/// Remove an overlay
void removeOverlay({required String id}) => RustLib.instance.api.crateApiRemoveOverlay(id: id);

/// Set view mode
void setViewMode({required String mode}) => RustLib.instance.api.crateApiSetViewMode(mode: mode);

/// Get current view mode
String getViewMode() => RustLib.instance.api.crateApiGetViewMode();

/// Georeferencing data from IFC site
class GeoReference {
  final double latitude;
  final double longitude;
  final double rotation;
  final double width;
  final double depth;
  final String? siteName;

  const GeoReference({
    required this.latitude,
    required this.longitude,
    required this.rotation,
    required this.width,
    required this.depth,
    this.siteName,
  });

  @override
  int get hashCode =>
      latitude.hashCode ^ longitude.hashCode ^ rotation.hashCode ^ width.hashCode ^ depth.hashCode ^ siteName.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GeoReference &&
          runtimeType == other.runtimeType &&
          latitude == other.latitude &&
          longitude == other.longitude &&
          rotation == other.rotation &&
          width == other.width &&
          depth == other.depth &&
          siteName == other.siteName;
}

/// Measurement point in 3D space
class MeasurementPoint {
  final double x;
  final double y;
  final double z;

  const MeasurementPoint({
    required this.x,
    required this.y,
    required this.z,
  });

  @override
  int get hashCode => x.hashCode ^ y.hashCode ^ z.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MeasurementPoint && runtimeType == other.runtimeType && x == other.x && y == other.y && z == other.z;
}

/// Measurement result
class MeasurementResult {
  final String measurementType;
  final double value;
  final String unit;
  final List<MeasurementPoint> points;

  const MeasurementResult({
    required this.measurementType,
    required this.value,
    required this.unit,
    required this.points,
  });

  @override
  int get hashCode => measurementType.hashCode ^ value.hashCode ^ unit.hashCode ^ points.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MeasurementResult &&
          runtimeType == other.runtimeType &&
          measurementType == other.measurementType &&
          value == other.value &&
          unit == other.unit &&
          points == other.points;
}

/// Get renderer statistics
class RenderStats {
  final double fps;
  final double frameTimeMs;
  final int triangleCount;
  final int vertexCount;
  final int elementCount;

  const RenderStats({
    required this.fps,
    required this.frameTimeMs,
    required this.triangleCount,
    required this.vertexCount,
    required this.elementCount,
  });

  @override
  int get hashCode =>
      fps.hashCode ^ frameTimeMs.hashCode ^ triangleCount.hashCode ^ vertexCount.hashCode ^ elementCount.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RenderStats &&
          runtimeType == other.runtimeType &&
          fps == other.fps &&
          frameTimeMs == other.frameTimeMs &&
          triangleCount == other.triangleCount &&
          vertexCount == other.vertexCount &&
          elementCount == other.elementCount;
}
