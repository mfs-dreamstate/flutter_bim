// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api.dart';
import 'bim/entities.dart';
import 'bim/geometry.dart';
import 'bim/model.dart';
import 'bim/model_registry.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.dart';
import 'frb_generated.io.dart' if (dart.library.js_interop) 'frb_generated.web.dart';
import 'lib.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

/// Main entrypoint of the Rust API
class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
  @internal
  static final instance = RustLib._();

  RustLib._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    RustLibApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
    bool forceSameCodegenVersion = true,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
      forceSameCodegenVersion: forceSameCodegenVersion,
    );
  }

  /// Initialize flutter_rust_bridge in mock mode.
  /// No libraries for FFI are loaded.
  static void initMock({
    required RustLibApi api,
  }) {
    instance.initMockImpl(
      api: api,
    );
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor => RustLibApiImpl.new;

  @override
  WireConstructor<RustLibWire> get wireConstructor => RustLibWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {}

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig => kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.11.1';

  @override
  int get rustContentHash => 219948847;

  static const kDefaultExternalLibraryLoaderConfig = ExternalLibraryLoaderConfig(
    stem: 'rust',
    ioDirectory: 'rust/target/release/',
    webPrefix: 'pkg/',
  );
}

abstract class RustLibApi extends BaseApi {
  int crateApiAddMeasurementPoint({required double x, required double y, required double z});

  void crateApiClearAllModels();

  void crateApiClearMeasurement();

  void crateApiClearSectionPlane();

  void crateApiColorByType();

  Future<void> crateApiExportScreenshot({required String path});

  void crateApiFitCameraToAllModels();

  void crateApiFitCameraToModel();

  List<ElementInfo> crateApiGetAllElements();

  List<ElementInfo> crateApiGetAllElementsFromAllModels();

  Uint8List crateApiGetCurrentFrameRgba();

  Map<String, BigInt> crateApiGetElementCounts();

  GeoReference? crateApiGetGeoReference();

  BigInt crateApiGetGridLineCount();

  List<GridLine> crateApiGetGridLines();

  List<String> crateApiGetHiddenElementTypes();

  int crateApiGetMeasurementPointCount();

  MeasurementResult crateApiGetMeasurementResult();

  BigInt crateApiGetModelCount();

  ModelInfo crateApiGetModelInfo();

  int crateApiGetRenderMode();

  RenderStats crateApiGetRenderStats();

  String crateApiGetSystemInfo();

  String crateApiGetVersion();

  String crateApiGetViewMode();

  Future<String> crateApiInitRenderer({required int width, required int height});

  String crateApiInitialize();

  bool crateApiIsElementTypeVisible({required String elementType});

  bool crateApiIsGridVisible();

  bool crateApiIsModelLoaded();

  bool crateApiIsRendererInitialized();

  bool crateApiIsSectionPlaneActive();

  bool crateApiIsWireframeSupported();

  List<RegisteredModelInfo> crateApiListLoadedModels();

  String crateApiLoadAllModelsIntoRenderer();

  Future<ModelInfo> crateApiLoadIfcFile({required String filePath});

  Future<ModelInfo> crateApiLoadModel({required String modelId, required String filePath});

  String crateApiLoadModelIntoRenderer();

  void crateApiOrbitCamera({required double deltaX, required double deltaY});

  Future<ModelInfo> crateApiParseIfcContent({required String content});

  ElementInfo? crateApiPickElement({required double screenX, required double screenY});

  String crateApiReloadAllModelsMesh();

  String crateApiReloadModelMesh();

  void crateApiRemoveOverlay({required String id});

  Uint8List crateApiRenderFrame();

  void crateApiResetElementColors();

  void crateApiSetAmbientColor({required double r, required double g, required double b});

  void crateApiSetElementColor({required int elementId, required int r, required int g, required int b});

  void crateApiSetElementTypeVisible({required String elementType, required bool visible});

  void crateApiSetGridVisible({required bool visible});

  void crateApiSetLightColor({required double r, required double g, required double b});

  void crateApiSetLightDirection({required double x, required double y, required double z});

  void crateApiSetLightIntensity({required double intensity});

  void crateApiSetModelVisible({required String modelId, required bool visible});

  void crateApiSetOverlayOpacity({required String id, required double opacity});

  void crateApiSetOverlayTransform(
      {required String id,
      required double positionX,
      required double positionY,
      required double positionZ,
      required double scaleX,
      required double scaleY,
      required double rotation});

  void crateApiSetOverlayVisible({required String id, required bool visible});

  void crateApiSetPrimaryModel({required String modelId});

  void crateApiSetRenderMode({required int mode});

  void crateApiSetSectionPlane(
      {required double originX,
      required double originY,
      required double originZ,
      required double normalX,
      required double normalY,
      required double normalZ});

  void crateApiSetSectionPlaneEnabled({required bool enabled});

  void crateApiSetSectionPlaneFromAxis({required int axis, required double position});

  void crateApiSetSelectedElement({int? elementId});

  void crateApiSetViewMode({required String mode});

  void crateApiStartMeasurement({required String measurementType});

  Future<String> crateApiTestAsync();

  String crateApiTestErrorHandling({required bool shouldFail});

  Future<String> crateApiTestRendererInit();

  bool crateApiToggleGridVisible();

  void crateApiUnloadModel();

  void crateApiUnloadModelById({required String modelId});

  Future<void> crateApiUploadDrawingOverlay(
      {required String id, required int width, required int height, required List<int> rgbaPixels});

  void crateApiZoomCamera({required double delta});
}

class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
  RustLibApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  int crateApiAddMeasurementPoint({required double x, required double y, required double z}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_f_32(x, serializer);
        sse_encode_f_32(y, serializer);
        sse_encode_f_32(z, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 1)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_32,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiAddMeasurementPointConstMeta,
      argValues: [x, y, z],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiAddMeasurementPointConstMeta => const TaskConstMeta(
        debugName: "add_measurement_point",
        argNames: ["x", "y", "z"],
      );

  @override
  void crateApiClearAllModels() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 2)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiClearAllModelsConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiClearAllModelsConstMeta => const TaskConstMeta(
        debugName: "clear_all_models",
        argNames: [],
      );

  @override
  void crateApiClearMeasurement() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 3)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiClearMeasurementConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiClearMeasurementConstMeta => const TaskConstMeta(
        debugName: "clear_measurement",
        argNames: [],
      );

  @override
  void crateApiClearSectionPlane() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 4)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiClearSectionPlaneConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiClearSectionPlaneConstMeta => const TaskConstMeta(
        debugName: "clear_section_plane",
        argNames: [],
      );

  @override
  void crateApiColorByType() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 5)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiColorByTypeConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiColorByTypeConstMeta => const TaskConstMeta(
        debugName: "color_by_type",
        argNames: [],
      );

  @override
  Future<void> crateApiExportScreenshot({required String path}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(path, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 6, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiExportScreenshotConstMeta,
      argValues: [path],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExportScreenshotConstMeta => const TaskConstMeta(
        debugName: "export_screenshot",
        argNames: ["path"],
      );

  @override
  void crateApiFitCameraToAllModels() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 7)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiFitCameraToAllModelsConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFitCameraToAllModelsConstMeta => const TaskConstMeta(
        debugName: "fit_camera_to_all_models",
        argNames: [],
      );

  @override
  void crateApiFitCameraToModel() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 8)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiFitCameraToModelConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFitCameraToModelConstMeta => const TaskConstMeta(
        debugName: "fit_camera_to_model",
        argNames: [],
      );

  @override
  List<ElementInfo> crateApiGetAllElements() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 9)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_element_info,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiGetAllElementsConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGetAllElementsConstMeta => const TaskConstMeta(
        debugName: "get_all_elements",
        argNames: [],
      );

  @override
  List<ElementInfo> crateApiGetAllElementsFromAllModels() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 10)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_element_info,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiGetAllElementsFromAllModelsConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGetAllElementsFromAllModelsConstMeta => const TaskConstMeta(
        debugName: "get_all_elements_from_all_models",
        argNames: [],
      );

  @override
  Uint8List crateApiGetCurrentFrameRgba() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 11)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiGetCurrentFrameRgbaConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGetCurrentFrameRgbaConstMeta => const TaskConstMeta(
        debugName: "get_current_frame_rgba",
        argNames: [],
      );

  @override
  Map<String, BigInt> crateApiGetElementCounts() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 12)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_Map_String_usize_None,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiGetElementCountsConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGetElementCountsConstMeta => const TaskConstMeta(
        debugName: "get_element_counts",
        argNames: [],
      );

  @override
  GeoReference? crateApiGetGeoReference() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 13)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_geo_reference,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiGetGeoReferenceConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGetGeoReferenceConstMeta => const TaskConstMeta(
        debugName: "get_geo_reference",
        argNames: [],
      );

  @override
  BigInt crateApiGetGridLineCount() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 14)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_usize,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiGetGridLineCountConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGetGridLineCountConstMeta => const TaskConstMeta(
        debugName: "get_grid_line_count",
        argNames: [],
      );

  @override
  List<GridLine> crateApiGetGridLines() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 15)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_grid_line,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiGetGridLinesConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGetGridLinesConstMeta => const TaskConstMeta(
        debugName: "get_grid_lines",
        argNames: [],
      );

  @override
  List<String> crateApiGetHiddenElementTypes() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 16)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiGetHiddenElementTypesConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGetHiddenElementTypesConstMeta => const TaskConstMeta(
        debugName: "get_hidden_element_types",
        argNames: [],
      );

  @override
  int crateApiGetMeasurementPointCount() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 17)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_32,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiGetMeasurementPointCountConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGetMeasurementPointCountConstMeta => const TaskConstMeta(
        debugName: "get_measurement_point_count",
        argNames: [],
      );

  @override
  MeasurementResult crateApiGetMeasurementResult() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 18)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_measurement_result,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiGetMeasurementResultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGetMeasurementResultConstMeta => const TaskConstMeta(
        debugName: "get_measurement_result",
        argNames: [],
      );

  @override
  BigInt crateApiGetModelCount() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 19)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_usize,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiGetModelCountConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGetModelCountConstMeta => const TaskConstMeta(
        debugName: "get_model_count",
        argNames: [],
      );

  @override
  ModelInfo crateApiGetModelInfo() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 20)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_model_info,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiGetModelInfoConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGetModelInfoConstMeta => const TaskConstMeta(
        debugName: "get_model_info",
        argNames: [],
      );

  @override
  int crateApiGetRenderMode() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 21)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_32,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiGetRenderModeConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGetRenderModeConstMeta => const TaskConstMeta(
        debugName: "get_render_mode",
        argNames: [],
      );

  @override
  RenderStats crateApiGetRenderStats() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 22)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_render_stats,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiGetRenderStatsConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGetRenderStatsConstMeta => const TaskConstMeta(
        debugName: "get_render_stats",
        argNames: [],
      );

  @override
  String crateApiGetSystemInfo() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 23)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiGetSystemInfoConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGetSystemInfoConstMeta => const TaskConstMeta(
        debugName: "get_system_info",
        argNames: [],
      );

  @override
  String crateApiGetVersion() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 24)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiGetVersionConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGetVersionConstMeta => const TaskConstMeta(
        debugName: "get_version",
        argNames: [],
      );

  @override
  String crateApiGetViewMode() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 25)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiGetViewModeConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGetViewModeConstMeta => const TaskConstMeta(
        debugName: "get_view_mode",
        argNames: [],
      );

  @override
  Future<String> crateApiInitRenderer({required int width, required int height}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_32(width, serializer);
        sse_encode_u_32(height, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 26, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiInitRendererConstMeta,
      argValues: [width, height],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiInitRendererConstMeta => const TaskConstMeta(
        debugName: "init_renderer",
        argNames: ["width", "height"],
      );

  @override
  String crateApiInitialize() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 27)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiInitializeConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiInitializeConstMeta => const TaskConstMeta(
        debugName: "initialize",
        argNames: [],
      );

  @override
  bool crateApiIsElementTypeVisible({required String elementType}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(elementType, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 28)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiIsElementTypeVisibleConstMeta,
      argValues: [elementType],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiIsElementTypeVisibleConstMeta => const TaskConstMeta(
        debugName: "is_element_type_visible",
        argNames: ["elementType"],
      );

  @override
  bool crateApiIsGridVisible() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 29)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiIsGridVisibleConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiIsGridVisibleConstMeta => const TaskConstMeta(
        debugName: "is_grid_visible",
        argNames: [],
      );

  @override
  bool crateApiIsModelLoaded() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 30)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiIsModelLoadedConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiIsModelLoadedConstMeta => const TaskConstMeta(
        debugName: "is_model_loaded",
        argNames: [],
      );

  @override
  bool crateApiIsRendererInitialized() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 31)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiIsRendererInitializedConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiIsRendererInitializedConstMeta => const TaskConstMeta(
        debugName: "is_renderer_initialized",
        argNames: [],
      );

  @override
  bool crateApiIsSectionPlaneActive() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 32)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiIsSectionPlaneActiveConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiIsSectionPlaneActiveConstMeta => const TaskConstMeta(
        debugName: "is_section_plane_active",
        argNames: [],
      );

  @override
  bool crateApiIsWireframeSupported() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 33)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiIsWireframeSupportedConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiIsWireframeSupportedConstMeta => const TaskConstMeta(
        debugName: "is_wireframe_supported",
        argNames: [],
      );

  @override
  List<RegisteredModelInfo> crateApiListLoadedModels() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 34)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_registered_model_info,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiListLoadedModelsConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiListLoadedModelsConstMeta => const TaskConstMeta(
        debugName: "list_loaded_models",
        argNames: [],
      );

  @override
  String crateApiLoadAllModelsIntoRenderer() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 35)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiLoadAllModelsIntoRendererConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiLoadAllModelsIntoRendererConstMeta => const TaskConstMeta(
        debugName: "load_all_models_into_renderer",
        argNames: [],
      );

  @override
  Future<ModelInfo> crateApiLoadIfcFile({required String filePath}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(filePath, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 36, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_model_info,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiLoadIfcFileConstMeta,
      argValues: [filePath],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiLoadIfcFileConstMeta => const TaskConstMeta(
        debugName: "load_ifc_file",
        argNames: ["filePath"],
      );

  @override
  Future<ModelInfo> crateApiLoadModel({required String modelId, required String filePath}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(modelId, serializer);
        sse_encode_String(filePath, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 37, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_model_info,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiLoadModelConstMeta,
      argValues: [modelId, filePath],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiLoadModelConstMeta => const TaskConstMeta(
        debugName: "load_model",
        argNames: ["modelId", "filePath"],
      );

  @override
  String crateApiLoadModelIntoRenderer() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 38)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiLoadModelIntoRendererConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiLoadModelIntoRendererConstMeta => const TaskConstMeta(
        debugName: "load_model_into_renderer",
        argNames: [],
      );

  @override
  void crateApiOrbitCamera({required double deltaX, required double deltaY}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_f_32(deltaX, serializer);
        sse_encode_f_32(deltaY, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 39)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiOrbitCameraConstMeta,
      argValues: [deltaX, deltaY],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiOrbitCameraConstMeta => const TaskConstMeta(
        debugName: "orbit_camera",
        argNames: ["deltaX", "deltaY"],
      );

  @override
  Future<ModelInfo> crateApiParseIfcContent({required String content}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(content, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 40, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_model_info,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiParseIfcContentConstMeta,
      argValues: [content],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiParseIfcContentConstMeta => const TaskConstMeta(
        debugName: "parse_ifc_content",
        argNames: ["content"],
      );

  @override
  ElementInfo? crateApiPickElement({required double screenX, required double screenY}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_f_32(screenX, serializer);
        sse_encode_f_32(screenY, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 41)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_element_info,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiPickElementConstMeta,
      argValues: [screenX, screenY],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiPickElementConstMeta => const TaskConstMeta(
        debugName: "pick_element",
        argNames: ["screenX", "screenY"],
      );

  @override
  String crateApiReloadAllModelsMesh() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 42)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiReloadAllModelsMeshConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiReloadAllModelsMeshConstMeta => const TaskConstMeta(
        debugName: "reload_all_models_mesh",
        argNames: [],
      );

  @override
  String crateApiReloadModelMesh() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 43)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiReloadModelMeshConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiReloadModelMeshConstMeta => const TaskConstMeta(
        debugName: "reload_model_mesh",
        argNames: [],
      );

  @override
  void crateApiRemoveOverlay({required String id}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(id, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 44)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiRemoveOverlayConstMeta,
      argValues: [id],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRemoveOverlayConstMeta => const TaskConstMeta(
        debugName: "remove_overlay",
        argNames: ["id"],
      );

  @override
  Uint8List crateApiRenderFrame() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 45)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiRenderFrameConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRenderFrameConstMeta => const TaskConstMeta(
        debugName: "render_frame",
        argNames: [],
      );

  @override
  void crateApiResetElementColors() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 46)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiResetElementColorsConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiResetElementColorsConstMeta => const TaskConstMeta(
        debugName: "reset_element_colors",
        argNames: [],
      );

  @override
  void crateApiSetAmbientColor({required double r, required double g, required double b}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_f_32(r, serializer);
        sse_encode_f_32(g, serializer);
        sse_encode_f_32(b, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 47)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiSetAmbientColorConstMeta,
      argValues: [r, g, b],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSetAmbientColorConstMeta => const TaskConstMeta(
        debugName: "set_ambient_color",
        argNames: ["r", "g", "b"],
      );

  @override
  void crateApiSetElementColor({required int elementId, required int r, required int g, required int b}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_i_32(elementId, serializer);
        sse_encode_u_8(r, serializer);
        sse_encode_u_8(g, serializer);
        sse_encode_u_8(b, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 48)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiSetElementColorConstMeta,
      argValues: [elementId, r, g, b],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSetElementColorConstMeta => const TaskConstMeta(
        debugName: "set_element_color",
        argNames: ["elementId", "r", "g", "b"],
      );

  @override
  void crateApiSetElementTypeVisible({required String elementType, required bool visible}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(elementType, serializer);
        sse_encode_bool(visible, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 49)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiSetElementTypeVisibleConstMeta,
      argValues: [elementType, visible],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSetElementTypeVisibleConstMeta => const TaskConstMeta(
        debugName: "set_element_type_visible",
        argNames: ["elementType", "visible"],
      );

  @override
  void crateApiSetGridVisible({required bool visible}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_bool(visible, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 50)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiSetGridVisibleConstMeta,
      argValues: [visible],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSetGridVisibleConstMeta => const TaskConstMeta(
        debugName: "set_grid_visible",
        argNames: ["visible"],
      );

  @override
  void crateApiSetLightColor({required double r, required double g, required double b}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_f_32(r, serializer);
        sse_encode_f_32(g, serializer);
        sse_encode_f_32(b, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 51)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiSetLightColorConstMeta,
      argValues: [r, g, b],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSetLightColorConstMeta => const TaskConstMeta(
        debugName: "set_light_color",
        argNames: ["r", "g", "b"],
      );

  @override
  void crateApiSetLightDirection({required double x, required double y, required double z}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_f_32(x, serializer);
        sse_encode_f_32(y, serializer);
        sse_encode_f_32(z, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 52)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiSetLightDirectionConstMeta,
      argValues: [x, y, z],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSetLightDirectionConstMeta => const TaskConstMeta(
        debugName: "set_light_direction",
        argNames: ["x", "y", "z"],
      );

  @override
  void crateApiSetLightIntensity({required double intensity}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_f_32(intensity, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 53)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiSetLightIntensityConstMeta,
      argValues: [intensity],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSetLightIntensityConstMeta => const TaskConstMeta(
        debugName: "set_light_intensity",
        argNames: ["intensity"],
      );

  @override
  void crateApiSetModelVisible({required String modelId, required bool visible}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(modelId, serializer);
        sse_encode_bool(visible, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 54)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiSetModelVisibleConstMeta,
      argValues: [modelId, visible],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSetModelVisibleConstMeta => const TaskConstMeta(
        debugName: "set_model_visible",
        argNames: ["modelId", "visible"],
      );

  @override
  void crateApiSetOverlayOpacity({required String id, required double opacity}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(id, serializer);
        sse_encode_f_32(opacity, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 55)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiSetOverlayOpacityConstMeta,
      argValues: [id, opacity],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSetOverlayOpacityConstMeta => const TaskConstMeta(
        debugName: "set_overlay_opacity",
        argNames: ["id", "opacity"],
      );

  @override
  void crateApiSetOverlayTransform(
      {required String id,
      required double positionX,
      required double positionY,
      required double positionZ,
      required double scaleX,
      required double scaleY,
      required double rotation}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(id, serializer);
        sse_encode_f_32(positionX, serializer);
        sse_encode_f_32(positionY, serializer);
        sse_encode_f_32(positionZ, serializer);
        sse_encode_f_32(scaleX, serializer);
        sse_encode_f_32(scaleY, serializer);
        sse_encode_f_32(rotation, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 56)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiSetOverlayTransformConstMeta,
      argValues: [id, positionX, positionY, positionZ, scaleX, scaleY, rotation],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSetOverlayTransformConstMeta => const TaskConstMeta(
        debugName: "set_overlay_transform",
        argNames: ["id", "positionX", "positionY", "positionZ", "scaleX", "scaleY", "rotation"],
      );

  @override
  void crateApiSetOverlayVisible({required String id, required bool visible}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(id, serializer);
        sse_encode_bool(visible, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 57)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiSetOverlayVisibleConstMeta,
      argValues: [id, visible],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSetOverlayVisibleConstMeta => const TaskConstMeta(
        debugName: "set_overlay_visible",
        argNames: ["id", "visible"],
      );

  @override
  void crateApiSetPrimaryModel({required String modelId}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(modelId, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 58)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiSetPrimaryModelConstMeta,
      argValues: [modelId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSetPrimaryModelConstMeta => const TaskConstMeta(
        debugName: "set_primary_model",
        argNames: ["modelId"],
      );

  @override
  void crateApiSetRenderMode({required int mode}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_i_32(mode, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 59)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiSetRenderModeConstMeta,
      argValues: [mode],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSetRenderModeConstMeta => const TaskConstMeta(
        debugName: "set_render_mode",
        argNames: ["mode"],
      );

  @override
  void crateApiSetSectionPlane(
      {required double originX,
      required double originY,
      required double originZ,
      required double normalX,
      required double normalY,
      required double normalZ}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_f_32(originX, serializer);
        sse_encode_f_32(originY, serializer);
        sse_encode_f_32(originZ, serializer);
        sse_encode_f_32(normalX, serializer);
        sse_encode_f_32(normalY, serializer);
        sse_encode_f_32(normalZ, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 60)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiSetSectionPlaneConstMeta,
      argValues: [originX, originY, originZ, normalX, normalY, normalZ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSetSectionPlaneConstMeta => const TaskConstMeta(
        debugName: "set_section_plane",
        argNames: ["originX", "originY", "originZ", "normalX", "normalY", "normalZ"],
      );

  @override
  void crateApiSetSectionPlaneEnabled({required bool enabled}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_bool(enabled, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 61)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiSetSectionPlaneEnabledConstMeta,
      argValues: [enabled],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSetSectionPlaneEnabledConstMeta => const TaskConstMeta(
        debugName: "set_section_plane_enabled",
        argNames: ["enabled"],
      );

  @override
  void crateApiSetSectionPlaneFromAxis({required int axis, required double position}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_i_32(axis, serializer);
        sse_encode_f_32(position, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 62)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiSetSectionPlaneFromAxisConstMeta,
      argValues: [axis, position],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSetSectionPlaneFromAxisConstMeta => const TaskConstMeta(
        debugName: "set_section_plane_from_axis",
        argNames: ["axis", "position"],
      );

  @override
  void crateApiSetSelectedElement({int? elementId}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_opt_box_autoadd_i_32(elementId, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 63)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiSetSelectedElementConstMeta,
      argValues: [elementId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSetSelectedElementConstMeta => const TaskConstMeta(
        debugName: "set_selected_element",
        argNames: ["elementId"],
      );

  @override
  void crateApiSetViewMode({required String mode}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(mode, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 64)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiSetViewModeConstMeta,
      argValues: [mode],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSetViewModeConstMeta => const TaskConstMeta(
        debugName: "set_view_mode",
        argNames: ["mode"],
      );

  @override
  void crateApiStartMeasurement({required String measurementType}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(measurementType, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 65)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiStartMeasurementConstMeta,
      argValues: [measurementType],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiStartMeasurementConstMeta => const TaskConstMeta(
        debugName: "start_measurement",
        argNames: ["measurementType"],
      );

  @override
  Future<String> crateApiTestAsync() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 66, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiTestAsyncConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiTestAsyncConstMeta => const TaskConstMeta(
        debugName: "test_async",
        argNames: [],
      );

  @override
  String crateApiTestErrorHandling({required bool shouldFail}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_bool(shouldFail, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 67)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiTestErrorHandlingConstMeta,
      argValues: [shouldFail],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiTestErrorHandlingConstMeta => const TaskConstMeta(
        debugName: "test_error_handling",
        argNames: ["shouldFail"],
      );

  @override
  Future<String> crateApiTestRendererInit() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 68, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiTestRendererInitConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiTestRendererInitConstMeta => const TaskConstMeta(
        debugName: "test_renderer_init",
        argNames: [],
      );

  @override
  bool crateApiToggleGridVisible() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 69)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiToggleGridVisibleConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiToggleGridVisibleConstMeta => const TaskConstMeta(
        debugName: "toggle_grid_visible",
        argNames: [],
      );

  @override
  void crateApiUnloadModel() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 70)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiUnloadModelConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUnloadModelConstMeta => const TaskConstMeta(
        debugName: "unload_model",
        argNames: [],
      );

  @override
  void crateApiUnloadModelById({required String modelId}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(modelId, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 71)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiUnloadModelByIdConstMeta,
      argValues: [modelId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUnloadModelByIdConstMeta => const TaskConstMeta(
        debugName: "unload_model_by_id",
        argNames: ["modelId"],
      );

  @override
  Future<void> crateApiUploadDrawingOverlay(
      {required String id, required int width, required int height, required List<int> rgbaPixels}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(id, serializer);
        sse_encode_u_32(width, serializer);
        sse_encode_u_32(height, serializer);
        sse_encode_list_prim_u_8_loose(rgbaPixels, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 72, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiUploadDrawingOverlayConstMeta,
      argValues: [id, width, height, rgbaPixels],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUploadDrawingOverlayConstMeta => const TaskConstMeta(
        debugName: "upload_drawing_overlay",
        argNames: ["id", "width", "height", "rgbaPixels"],
      );

  @override
  void crateApiZoomCamera({required double delta}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_f_32(delta, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 73)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiZoomCameraConstMeta,
      argValues: [delta],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiZoomCameraConstMeta => const TaskConstMeta(
        debugName: "zoom_camera",
        argNames: ["delta"],
      );

  @protected
  Map<String, BigInt> dco_decode_Map_String_usize_None(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Map.fromEntries(dco_decode_list_record_string_usize(raw).map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  BoundingBox dco_decode_bounding_box(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return BoundingBox(
      min: dco_decode_f_32_array_3(arr[0]),
      max: dco_decode_f_32_array_3(arr[1]),
    );
  }

  @protected
  ElementInfo dco_decode_box_autoadd_element_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_element_info(raw);
  }

  @protected
  GeoReference dco_decode_box_autoadd_geo_reference(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_geo_reference(raw);
  }

  @protected
  int dco_decode_box_autoadd_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  ElementInfo dco_decode_element_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7) throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return ElementInfo(
      id: dco_decode_i_32(arr[0]),
      elementType: dco_decode_String(arr[1]),
      name: dco_decode_String(arr[2]),
      globalId: dco_decode_String(arr[3]),
      bounds: dco_decode_bounding_box(arr[4]),
      triangleStart: dco_decode_u_32(arr[5]),
      triangleCount: dco_decode_u_32(arr[6]),
    );
  }

  @protected
  double dco_decode_f_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  F32Array3 dco_decode_f_32_array_3(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return F32Array3(dco_decode_list_prim_f_32_strict(raw));
  }

  @protected
  double dco_decode_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  GeoReference dco_decode_geo_reference(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6) throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return GeoReference(
      latitude: dco_decode_f_64(arr[0]),
      longitude: dco_decode_f_64(arr[1]),
      rotation: dco_decode_f_64(arr[2]),
      width: dco_decode_f_64(arr[3]),
      depth: dco_decode_f_64(arr[4]),
      siteName: dco_decode_opt_String(arr[5]),
    );
  }

  @protected
  GridLine dco_decode_grid_line(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4) throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return GridLine(
      tag: dco_decode_String(arr[0]),
      start: dco_decode_f_32_array_3(arr[1]),
      end: dco_decode_f_32_array_3(arr[2]),
      isUAxis: dco_decode_bool(arr[3]),
    );
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  List<String> dco_decode_list_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_String).toList();
  }

  @protected
  List<ElementInfo> dco_decode_list_element_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_element_info).toList();
  }

  @protected
  List<GridLine> dco_decode_list_grid_line(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_grid_line).toList();
  }

  @protected
  List<MeasurementPoint> dco_decode_list_measurement_point(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_measurement_point).toList();
  }

  @protected
  Float32List dco_decode_list_prim_f_32_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Float32List;
  }

  @protected
  List<int> dco_decode_list_prim_u_8_loose(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as List<int>;
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  List<(String, BigInt)> dco_decode_list_record_string_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_record_string_usize).toList();
  }

  @protected
  List<RegisteredModelInfo> dco_decode_list_registered_model_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_registered_model_info).toList();
  }

  @protected
  MeasurementPoint dco_decode_measurement_point(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return MeasurementPoint(
      x: dco_decode_f_32(arr[0]),
      y: dco_decode_f_32(arr[1]),
      z: dco_decode_f_32(arr[2]),
    );
  }

  @protected
  MeasurementResult dco_decode_measurement_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4) throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return MeasurementResult(
      measurementType: dco_decode_String(arr[0]),
      value: dco_decode_f_64(arr[1]),
      unit: dco_decode_String(arr[2]),
      points: dco_decode_list_measurement_point(arr[3]),
    );
  }

  @protected
  ModelInfo dco_decode_model_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4) throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return ModelInfo(
      projectName: dco_decode_String(arr[0]),
      buildingName: dco_decode_String(arr[1]),
      siteName: dco_decode_String(arr[2]),
      stats: dco_decode_model_stats(arr[3]),
    );
  }

  @protected
  ModelStats dco_decode_model_stats(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 8) throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
    return ModelStats(
      totalEntities: dco_decode_usize(arr[0]),
      walls: dco_decode_usize(arr[1]),
      slabs: dco_decode_usize(arr[2]),
      columns: dco_decode_usize(arr[3]),
      beams: dco_decode_usize(arr[4]),
      doors: dco_decode_usize(arr[5]),
      windows: dco_decode_usize(arr[6]),
      storeys: dco_decode_usize(arr[7]),
    );
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  ElementInfo? dco_decode_opt_box_autoadd_element_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_element_info(raw);
  }

  @protected
  GeoReference? dco_decode_opt_box_autoadd_geo_reference(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_geo_reference(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_i_32(raw);
  }

  @protected
  (String, BigInt) dco_decode_record_string_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_String(arr[0]),
      dco_decode_usize(arr[1]),
    );
  }

  @protected
  RegisteredModelInfo dco_decode_registered_model_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6) throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return RegisteredModelInfo(
      id: dco_decode_String(arr[0]),
      name: dco_decode_String(arr[1]),
      filePath: dco_decode_opt_String(arr[2]),
      visible: dco_decode_bool(arr[3]),
      isPrimary: dco_decode_bool(arr[4]),
      modelInfo: dco_decode_model_info(arr[5]),
    );
  }

  @protected
  RenderStats dco_decode_render_stats(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5) throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return RenderStats(
      fps: dco_decode_f_32(arr[0]),
      frameTimeMs: dco_decode_f_32(arr[1]),
      triangleCount: dco_decode_u_32(arr[2]),
      vertexCount: dco_decode_u_32(arr[3]),
      elementCount: dco_decode_u_32(arr[4]),
    );
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  BigInt dco_decode_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  Map<String, BigInt> sse_decode_Map_String_usize_None(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_record_string_usize(deserializer);
    return Map.fromEntries(inner.map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  BoundingBox sse_decode_bounding_box(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_min = sse_decode_f_32_array_3(deserializer);
    var var_max = sse_decode_f_32_array_3(deserializer);
    return BoundingBox(min: var_min, max: var_max);
  }

  @protected
  ElementInfo sse_decode_box_autoadd_element_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_element_info(deserializer));
  }

  @protected
  GeoReference sse_decode_box_autoadd_geo_reference(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_geo_reference(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_i_32(deserializer));
  }

  @protected
  ElementInfo sse_decode_element_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_i_32(deserializer);
    var var_elementType = sse_decode_String(deserializer);
    var var_name = sse_decode_String(deserializer);
    var var_globalId = sse_decode_String(deserializer);
    var var_bounds = sse_decode_bounding_box(deserializer);
    var var_triangleStart = sse_decode_u_32(deserializer);
    var var_triangleCount = sse_decode_u_32(deserializer);
    return ElementInfo(
        id: var_id,
        elementType: var_elementType,
        name: var_name,
        globalId: var_globalId,
        bounds: var_bounds,
        triangleStart: var_triangleStart,
        triangleCount: var_triangleCount);
  }

  @protected
  double sse_decode_f_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getFloat32();
  }

  @protected
  F32Array3 sse_decode_f_32_array_3(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_f_32_strict(deserializer);
    return F32Array3(inner);
  }

  @protected
  double sse_decode_f_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getFloat64();
  }

  @protected
  GeoReference sse_decode_geo_reference(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_latitude = sse_decode_f_64(deserializer);
    var var_longitude = sse_decode_f_64(deserializer);
    var var_rotation = sse_decode_f_64(deserializer);
    var var_width = sse_decode_f_64(deserializer);
    var var_depth = sse_decode_f_64(deserializer);
    var var_siteName = sse_decode_opt_String(deserializer);
    return GeoReference(
        latitude: var_latitude,
        longitude: var_longitude,
        rotation: var_rotation,
        width: var_width,
        depth: var_depth,
        siteName: var_siteName);
  }

  @protected
  GridLine sse_decode_grid_line(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_tag = sse_decode_String(deserializer);
    var var_start = sse_decode_f_32_array_3(deserializer);
    var var_end = sse_decode_f_32_array_3(deserializer);
    var var_isUAxis = sse_decode_bool(deserializer);
    return GridLine(tag: var_tag, start: var_start, end: var_end, isUAxis: var_isUAxis);
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  List<String> sse_decode_list_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <String>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_String(deserializer));
    }
    return ans_;
  }

  @protected
  List<ElementInfo> sse_decode_list_element_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ElementInfo>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_element_info(deserializer));
    }
    return ans_;
  }

  @protected
  List<GridLine> sse_decode_list_grid_line(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <GridLine>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_grid_line(deserializer));
    }
    return ans_;
  }

  @protected
  List<MeasurementPoint> sse_decode_list_measurement_point(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <MeasurementPoint>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_measurement_point(deserializer));
    }
    return ans_;
  }

  @protected
  Float32List sse_decode_list_prim_f_32_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getFloat32List(len_);
  }

  @protected
  List<int> sse_decode_list_prim_u_8_loose(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  List<(String, BigInt)> sse_decode_list_record_string_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(String, BigInt)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_record_string_usize(deserializer));
    }
    return ans_;
  }

  @protected
  List<RegisteredModelInfo> sse_decode_list_registered_model_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <RegisteredModelInfo>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_registered_model_info(deserializer));
    }
    return ans_;
  }

  @protected
  MeasurementPoint sse_decode_measurement_point(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_x = sse_decode_f_32(deserializer);
    var var_y = sse_decode_f_32(deserializer);
    var var_z = sse_decode_f_32(deserializer);
    return MeasurementPoint(x: var_x, y: var_y, z: var_z);
  }

  @protected
  MeasurementResult sse_decode_measurement_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_measurementType = sse_decode_String(deserializer);
    var var_value = sse_decode_f_64(deserializer);
    var var_unit = sse_decode_String(deserializer);
    var var_points = sse_decode_list_measurement_point(deserializer);
    return MeasurementResult(
        measurementType: var_measurementType, value: var_value, unit: var_unit, points: var_points);
  }

  @protected
  ModelInfo sse_decode_model_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_projectName = sse_decode_String(deserializer);
    var var_buildingName = sse_decode_String(deserializer);
    var var_siteName = sse_decode_String(deserializer);
    var var_stats = sse_decode_model_stats(deserializer);
    return ModelInfo(
        projectName: var_projectName, buildingName: var_buildingName, siteName: var_siteName, stats: var_stats);
  }

  @protected
  ModelStats sse_decode_model_stats(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_totalEntities = sse_decode_usize(deserializer);
    var var_walls = sse_decode_usize(deserializer);
    var var_slabs = sse_decode_usize(deserializer);
    var var_columns = sse_decode_usize(deserializer);
    var var_beams = sse_decode_usize(deserializer);
    var var_doors = sse_decode_usize(deserializer);
    var var_windows = sse_decode_usize(deserializer);
    var var_storeys = sse_decode_usize(deserializer);
    return ModelStats(
        totalEntities: var_totalEntities,
        walls: var_walls,
        slabs: var_slabs,
        columns: var_columns,
        beams: var_beams,
        doors: var_doors,
        windows: var_windows,
        storeys: var_storeys);
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  ElementInfo? sse_decode_opt_box_autoadd_element_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_element_info(deserializer));
    } else {
      return null;
    }
  }

  @protected
  GeoReference? sse_decode_opt_box_autoadd_geo_reference(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_geo_reference(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_i_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  (String, BigInt) sse_decode_record_string_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_String(deserializer);
    var var_field1 = sse_decode_usize(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  RegisteredModelInfo sse_decode_registered_model_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_name = sse_decode_String(deserializer);
    var var_filePath = sse_decode_opt_String(deserializer);
    var var_visible = sse_decode_bool(deserializer);
    var var_isPrimary = sse_decode_bool(deserializer);
    var var_modelInfo = sse_decode_model_info(deserializer);
    return RegisteredModelInfo(
        id: var_id,
        name: var_name,
        filePath: var_filePath,
        visible: var_visible,
        isPrimary: var_isPrimary,
        modelInfo: var_modelInfo);
  }

  @protected
  RenderStats sse_decode_render_stats(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_fps = sse_decode_f_32(deserializer);
    var var_frameTimeMs = sse_decode_f_32(deserializer);
    var var_triangleCount = sse_decode_u_32(deserializer);
    var var_vertexCount = sse_decode_u_32(deserializer);
    var var_elementCount = sse_decode_u_32(deserializer);
    return RenderStats(
        fps: var_fps,
        frameTimeMs: var_frameTimeMs,
        triangleCount: var_triangleCount,
        vertexCount: var_vertexCount,
        elementCount: var_elementCount);
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  BigInt sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  void sse_encode_Map_String_usize_None(Map<String, BigInt> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_record_string_usize(self.entries.map((e) => (e.key, e.value)).toList(), serializer);
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_bounding_box(BoundingBox self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_32_array_3(self.min, serializer);
    sse_encode_f_32_array_3(self.max, serializer);
  }

  @protected
  void sse_encode_box_autoadd_element_info(ElementInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_element_info(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_geo_reference(GeoReference self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_geo_reference(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self, serializer);
  }

  @protected
  void sse_encode_element_info(ElementInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.id, serializer);
    sse_encode_String(self.elementType, serializer);
    sse_encode_String(self.name, serializer);
    sse_encode_String(self.globalId, serializer);
    sse_encode_bounding_box(self.bounds, serializer);
    sse_encode_u_32(self.triangleStart, serializer);
    sse_encode_u_32(self.triangleCount, serializer);
  }

  @protected
  void sse_encode_f_32(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putFloat32(self);
  }

  @protected
  void sse_encode_f_32_array_3(F32Array3 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_f_32_strict(self.inner, serializer);
  }

  @protected
  void sse_encode_f_64(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putFloat64(self);
  }

  @protected
  void sse_encode_geo_reference(GeoReference self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_64(self.latitude, serializer);
    sse_encode_f_64(self.longitude, serializer);
    sse_encode_f_64(self.rotation, serializer);
    sse_encode_f_64(self.width, serializer);
    sse_encode_f_64(self.depth, serializer);
    sse_encode_opt_String(self.siteName, serializer);
  }

  @protected
  void sse_encode_grid_line(GridLine self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.tag, serializer);
    sse_encode_f_32_array_3(self.start, serializer);
    sse_encode_f_32_array_3(self.end, serializer);
    sse_encode_bool(self.isUAxis, serializer);
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_list_String(List<String> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_String(item, serializer);
    }
  }

  @protected
  void sse_encode_list_element_info(List<ElementInfo> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_element_info(item, serializer);
    }
  }

  @protected
  void sse_encode_list_grid_line(List<GridLine> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_grid_line(item, serializer);
    }
  }

  @protected
  void sse_encode_list_measurement_point(List<MeasurementPoint> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_measurement_point(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_f_32_strict(Float32List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putFloat32List(self);
  }

  @protected
  void sse_encode_list_prim_u_8_loose(List<int> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self is Uint8List ? self : Uint8List.fromList(self));
  }

  @protected
  void sse_encode_list_prim_u_8_strict(Uint8List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_record_string_usize(List<(String, BigInt)> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_string_usize(item, serializer);
    }
  }

  @protected
  void sse_encode_list_registered_model_info(List<RegisteredModelInfo> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_registered_model_info(item, serializer);
    }
  }

  @protected
  void sse_encode_measurement_point(MeasurementPoint self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_32(self.x, serializer);
    sse_encode_f_32(self.y, serializer);
    sse_encode_f_32(self.z, serializer);
  }

  @protected
  void sse_encode_measurement_result(MeasurementResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.measurementType, serializer);
    sse_encode_f_64(self.value, serializer);
    sse_encode_String(self.unit, serializer);
    sse_encode_list_measurement_point(self.points, serializer);
  }

  @protected
  void sse_encode_model_info(ModelInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.projectName, serializer);
    sse_encode_String(self.buildingName, serializer);
    sse_encode_String(self.siteName, serializer);
    sse_encode_model_stats(self.stats, serializer);
  }

  @protected
  void sse_encode_model_stats(ModelStats self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.totalEntities, serializer);
    sse_encode_usize(self.walls, serializer);
    sse_encode_usize(self.slabs, serializer);
    sse_encode_usize(self.columns, serializer);
    sse_encode_usize(self.beams, serializer);
    sse_encode_usize(self.doors, serializer);
    sse_encode_usize(self.windows, serializer);
    sse_encode_usize(self.storeys, serializer);
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_element_info(ElementInfo? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_element_info(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_geo_reference(GeoReference? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_geo_reference(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_i_32(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_i_32(self, serializer);
    }
  }

  @protected
  void sse_encode_record_string_usize((String, BigInt) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.$1, serializer);
    sse_encode_usize(self.$2, serializer);
  }

  @protected
  void sse_encode_registered_model_info(RegisteredModelInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.name, serializer);
    sse_encode_opt_String(self.filePath, serializer);
    sse_encode_bool(self.visible, serializer);
    sse_encode_bool(self.isPrimary, serializer);
    sse_encode_model_info(self.modelInfo, serializer);
  }

  @protected
  void sse_encode_render_stats(RenderStats self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_32(self.fps, serializer);
    sse_encode_f_32(self.frameTimeMs, serializer);
    sse_encode_u_32(self.triangleCount, serializer);
    sse_encode_u_32(self.vertexCount, serializer);
    sse_encode_u_32(self.elementCount, serializer);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_usize(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }
}
